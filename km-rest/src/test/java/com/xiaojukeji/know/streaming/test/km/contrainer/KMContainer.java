package com.xiaojukeji.know.streaming.test.km.contrainer;

import com.xiaojukeji.know.streaming.test.km.env.KMEnv;
import org.jetbrains.annotations.NotNull;
import org.testcontainers.containers.GenericContainer;
import org.testcontainers.containers.MySQLContainer;
import org.testcontainers.elasticsearch.ElasticsearchContainer;
import org.testcontainers.lifecycle.Startables;
import org.testcontainers.utility.DockerImageName;

import java.util.function.Supplier;

public class KMContainer implements KMEnv {
    private static final String ES_VERSION = "7.6.2";
    private static final String LATEST_VERSION = "latest";

    private static final String DB_PROPERTY = "?useUnicode=true" +
            "&characterEncoding=utf8" +
            "&jdbcCompliantTruncation=true" +
            "&allowMultiQueries=true" +
            "&useSSL=false" +
            "&alwaysAutoGeneratedKeys=true" +
            "&serverTimezone=GMT%2B8" +
            "&allowPublicKeyRetrieval=true";
    private static final DockerImageName ES_IMAGE = DockerImageName.parse(
                    "docker.io/library/elasticsearch" + KMEnv.SEPARATOR + ES_VERSION)
            .asCompatibleSubstituteFor("docker.elastic.co/elasticsearch/elasticsearch");
    private static final DockerImageName MYSQL_IMAGE = DockerImageName.parse(
                    "knowstreaming/knowstreaming-mysql" + KMEnv.SEPARATOR + LATEST_VERSION)
            .asCompatibleSubstituteFor("mysql");

    private static final DockerImageName INIT_IMAGE = DockerImageName.parse(
            "knowstreaming/knowstreaming-manager" + KMEnv.SEPARATOR + LATEST_VERSION);

    private static final ElasticsearchContainer ES_CONTAINER = new ElasticsearchContainer(ES_IMAGE)
//            .withImagePullPolicy(PullPolicy.alwaysPull())
            .withEnv("TZ", "Asia/Shanghai")
            .withEnv("ES_JAVA_OPTS", "-Xms512m -Xmx512m")
            .withEnv("discovery.type", "single-node");
    private static final GenericContainer<?> INIT_CONTAINER = new GenericContainer<>(INIT_IMAGE)
            .withEnv("TZ", "Asia/Shanghai")
            .withCommand("/bin/bash", "/es_template_create.sh")
            .dependsOn(ES_CONTAINER);
    private static final MySQLContainer<?> MYSQL_CONTAINER = new MySQLContainer<>(MYSQL_IMAGE)
            .withEnv("MYSQL_ROOT_HOST", "%")
            .withEnv("TZ", "Asia/Shanghai")
            .withDatabaseName("know_streaming")
            .withUsername("root")
            .withPassword("mysql_pass");


    @NotNull
    public Supplier<Object> jdbcUrl() {
        return () -> "jdbc:mariadb://"
                + MYSQL_CONTAINER.getHost() + ":" + MYSQL_CONTAINER.getMappedPort(3306)
                + "/know_streaming" + DB_PROPERTY;
    }

    @NotNull
    public Supplier<Object> esUrl() {
        return () -> ES_CONTAINER.getHost() + ":" + ES_CONTAINER.getMappedPort(9200);
    }

    @Override
    public void init() {
        if (es()) {
            Startables.deepStart(ES_CONTAINER, INIT_CONTAINER).join();
        }

        if (mysql()) {
            Startables.deepStart(MYSQL_CONTAINER).join();
        }
    }

    @Override
    public void cleanup() {
        /*
         * 不需要手动调用清理容器
         * 1. test执行结束后testcontainer会清理容器
         * 2. junit5的@AfterAll方法会在SpringBoot生命周期结束前执行，导致数据库连接无法关闭
         **/
//        if (ES_CONTAINER != null) {
//            ES_CONTAINER.close();
//        }
//        if (INIT_CONTAINER != null) {
//            INIT_CONTAINER.close();
//        }
//        if (MYSQL_CONTAINER != null) {
//            MYSQL_CONTAINER.close();
//        }
    }
}
